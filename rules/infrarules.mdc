---
alwaysApply: true
---

üß© Regras gerais deste reposit√≥rio (Infra / Terraform / Kubernetes)

Este reposit√≥rio √© respons√°vel por infraestrutura, n√£o por l√≥gica de neg√≥cio.

Tudo que for criado na cloud deve ser descrito em Terraform ou em manifestos Kubernetes ‚Äì nada de "ajeitar no console" sem voltar para o c√≥digo.

Manter o padr√£o de organiza√ß√£o atual:

Infra AWS: diret√≥rio terraform/

Manifests Kubernetes: diret√≥rio k8s/ (subpastas app/ e infra/)

Sempre que copiar algo de outro projeto, adaptar nomes, vari√°veis e coment√°rios para o contexto atual (n√£o deixar fastfood perdido se o nome do projeto mudar).

=====================
1. REGRAS DE TERRAFORM
=====================

1.1. Vers√£o e providers

Sempre usar bloco terraform com required_version >= 1.0.

Sempre usar o provider AWS da fam√≠lia ~> 5.0 (como j√° est√° em providers.tf).

O provider principal deve continuar assim:

```hcl
provider "aws" {
  region = var.aws_region
}
```

N√£o hardcodear a regi√£o diretamente no provider, sempre via var.aws_region.

1.2. Backend remoto (state)

O backend deve ser sempre S3, nunca local.

O arquivo backend.tf √© o dono √∫nico da configura√ß√£o do backend.

N√£o alterar o bucket de state sem motivo fort√≠ssimo; se precisar trocar:

Ajustar bucket, key e region em backend.tf.

Garantir que o bucket exista antes de rodar terraform init.

Nunca commitar terraform.tfstate ou .terraform/ no reposit√≥rio.

1.3. Organiza√ß√£o de arquivos

Manter um arquivo por responsabilidade, como j√° est√° hoje:

providers.tf ‚Üí vers√£o do Terraform e provider AWS

backend.tf ‚Üí configura√ß√£o de backend S3

datasource.tf ‚Üí data "aws_*" e helpers de descoberta

network.tf ‚Üí VPC default e subnets do EKS

sg.tf ‚Üí Security Group principal (cluster / exposi√ß√£o externa)

eks-cluster.tf ‚Üí recurso aws_eks_cluster

eks-node.tf ‚Üí recurso aws_eks_node_group

eks-access-policy.tf / access-entry.tf ‚Üí acesso ao cluster (IAM/EKS)

ecr.tf ‚Üí reposit√≥rios ECR

network-rds.tf ‚Üí regra SG entre EKS e RDS

variables.tf ‚Üí todas as vari√°veis de entrada

outputs.tf ‚Üí todos os outputs p√∫blicos

Ao adicionar novos recursos, reutilizar esse padr√£o:

Se for algo de rede ‚Üí network-*.tf

Se for algo de seguran√ßa ‚Üí sg-*.tf

Se for algo de observabilidade ‚Üí monitoring-*.tf

N√£o criar arquivos gigantes com tudo misturado.

1.4. Vari√°veis, nomes e tags

Todas as coisas "imut√°veis por ambiente" devem ser parametrizadas:

project_name

env

aws_region

lab_role

policy_arn

principal_arn

Manter o padr√£o de nome de recursos:

```hcl
name = "${var.project_name}-api"
name = "eks-${var.project_name}"
node_group_name = "nodeg-${var.project_name}"
```

Sempre usar tags m√≠nimas em todos os recursos suportados:

```hcl
tags = {
  Name        = "${var.project_name}-<alguma-coisa>"
  Environment = var.env
  Project     = var.project_name
}
```

Quando adicionar novos recursos (SQS, Dynamo, RDS, etc.), seguir esse mesmo padr√£o de tags e nomes.

1.5. Uso de AWS Academy (LabRole) e autentica√ß√£o da infra

N√£o criar novas roles "admin" no Terraform.

Para o cluster EKS e Node Group:

role_arn do EKS deve usar var.lab_role.

node_role_arn do Node Group deve usar var.lab_role.

var.lab_role, var.policy_arn e var.principal_arn devem continuar configur√°veis via variables.tf.

Manter e usar os recursos de acesso do EKS:

aws_eks_access_policy_association

aws_eks_access_entry

Esses recursos devem continuar apontando para:

cluster_name = aws_eks_cluster.cluster.name

policy_arn = var.policy_arn

principal_arn = var.principal_arn

N√£o hardcodear ARN da role do aluno dentro dos recursos; sempre usar var.principal_arn e var.lab_role.

1.6. VPC e Subnets

Sempre usar a VPC default da conta:

```hcl
data "aws_vpc" "default" { default = true }
```

Subnets do cluster devem ser descobertas via data "aws_subnets" filtrando pela VPC default e pelas AZs permitidas:

Excluir explicitamente us-east-1e (n√£o suportada no Academy).

N√£o criar uma nova VPC neste projeto de infra ‚Äì isso √© restrito no ambiente AWS Academy e n√£o √© necess√°rio para a entrega.

1.7. Security Groups e Regras

O security group principal (arquivo sg.tf) √© respons√°vel pela exposi√ß√£o p√∫blica (HTTP/HTTPS):

Expor apenas portas necess√°rias (80/443).

Egress liberado (0.0.0.0/0) √© aceit√°vel para MVP, mas n√£o abrir ingress desnecess√°rio.

Para comunica√ß√£o EKS ‚Üí RDS:

Usar network-rds.tf para criar regras via aws_security_group_rule.

Nunca abrir RDS para 0.0.0.0/0.

Sempre restringir a SG rule usando eks_node_sg_id + rds_sg_id (vari√°veis).

A porta deve ser compat√≠vel com o banco:

MySQL: 3306

PostgreSQL: 5432

N√£o misturar regras de SG da aplica√ß√£o com regras de SG do banco no mesmo bloco sem necessidade.

1.8. Cluster EKS e Node Group (padr√£o)

O recurso de cluster deve seguir a linha atual:

```hcl
resource "aws_eks_cluster" "cluster" {
  name = "eks-${var.project_name}"

  access_config {
    authentication_mode = "API"
  }

  role_arn = var.lab_role
  version  = var.eks_version

  vpc_config {
    subnet_ids         = data.aws_subnets.eks_supported.ids
    security_group_ids = [aws_security_group.sg.id]
  }
}
```

O Node Group deve:

Usar node_role_arn = var.lab_role

Utilizar scaling_config com min=2, desired=2, max=3 (ou parametrizar isso se necess√°rio).

Usar update_config { max_unavailable = 1 }.

Pegar instance_types de var.instance_types.

1.9. ECR ‚Äì Reposit√≥rios de imagens

Manter o padr√£o de ECR com var.manage_ecr (feature flag):

Quando manage_ecr = true ‚Üí cria os reposit√≥rios.

Quando manage_ecr = false ‚Üí n√£o cria nada e devolve mensagens amig√°veis nos outputs.

Todos os ECR precisam:

image_tag_mutability = "MUTABLE" (a n√£o ser que voc√™ tenha motivo para IMMUTABLE).

image_scanning_configuration { scan_on_push = true }.

force_delete = true para facilitar limpeza no ambiente de laborat√≥rio.

Lifecycle policy para expirar imagens antigas/untagged (j√° existe, manter o padr√£o).

Sempre nomear ECR com ${var.project_name}-<sufixo> e tags padr√£o.

1.10. Data sources e outputs

Nunca hardcodear IDs de recursos que possam ser descobertos com data "aws_*".

datasource.tf deve centralizar:

data "aws_caller_identity" "current"

data "aws_eks_cluster" / data "aws_eks_cluster_auth" para pegar endpoint e CA.

outputs.tf deve:

Expor somente o que for √∫til para:

Configurar o kubeconfig do EKS

Pipelines de deploy dos servi√ßos

Conectar RDS/EKS

Exemplo obrigat√≥rio:

eks_name

eks_endpoint

eks_ca

URLs dos ECR (quando manage_ecr = true)

1.11. Boas pr√°ticas gerais de c√≥digo Terraform

Sempre rodar:

terraform fmt antes de commitar.

terraform validate antes de aplicar.

**OBRIGAT√ìRIO:** Antes de commitar qualquer mudan√ßa em arquivos Terraform:

1. Executar `terraform init` (se novos m√≥dulos foram adicionados)
2. Executar `terraform fmt -recursive` para formatar todos os arquivos
3. Executar `terraform validate` e garantir que retorna "Success! The configuration is valid."
4. Corrigir todos os erros de valida√ß√£o antes de commitar

Nenhum c√≥digo Terraform deve ser commitado com erros de valida√ß√£o.

N√£o usar vari√°veis locais para coisas sens√≠veis (senhas, tokens).

Senhas, tokens, connection strings:

Nunca em texto puro em .tf.

Devem ir para:

AWS Secrets Manager (ideal)

Ou, no m√≠nimo, como vari√°veis de ambiente nos pipelines, injetadas em Kubernetes Secret.

N√£o commitar arquivos:

*.tfstate

*.tfstate.backup

.terraform/

Arquivos .tfplan (como plan.tfplan).

=====================
2. REGRAS DE KUBERNETES (manifests em /k8s)
=====================

2.1. Organiza√ß√£o

Manifests de aplica√ß√£o ficam em k8s/app/<servi√ßo>/.

Exemplo atual: k8s/app/api/ cont√©m:

api-deployment.yaml

api-service.yaml

api-hpa.yaml

Manifests de infraestrutura/shared ficam em k8s/infra/:

namespace.yaml

infra/configmap/

infra/metrics/ (metrics-server, etc.)

2.2. Namespaces

Nunca usar o namespace default para aplica√ß√µes desse projeto.

Sempre usar um Namespace expl√≠cito (arquivo namespace.yaml) com placeholder <NAMESPACE>.

Para cada ambiente ou contexto (orderhub, paystream, kitchenflow), usar um namespace claro:

orderhub

paystream

kitchenflow

Antes de criar novos manifests, verificar se:

metadata.namespace est√° definido corretamente.

O namespace est√° sendo criado por manifesto infra (namespace.yaml).

2.3. Deployments

Sempre usar kind: Deployment para as APIs.

Padr√µes obrigat√≥rios:

strategy: RollingUpdate com maxUnavailable: 0 e maxSurge: 1 (ou valores similares de rollout seguro).

spec.selector.matchLabels deve bater com spec.template.metadata.labels.

Imagem deve vir de ECR, nunca de Docker Hub p√∫blico para a aplica√ß√£o principal.

Container principal:

Ter ports.containerPort nomeado (name: http) quando for HTTP.

Ter resources.requests e resources.limits definidos (CPU e mem√≥ria).

Vari√°veis de ambiente sens√≠veis via envFrom.secretRef.

Configura√ß√£o n√£o sens√≠vel via envFrom.configMapRef.

2.4. Services

Cada aplica√ß√£o exposta externamente deve ter um Service separado.

Para comunica√ß√£o p√∫blica:

Usar type: LoadBalancer.

Manter annotations para NLB / internet-facing, como no exemplo atual:

service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing

service.beta.kubernetes.io/aws-load-balancer-type: nlb

spec.selector deve casar com os labels do Deployment.

externalTrafficPolicy: Cluster √© aceit√°vel para o seu caso; n√£o mudar para Local sem necessidade.

2.5. HPA (Horizontal Pod Autoscaler)

Sempre usar autoscaling/v2 com m√©tricas de CPU (e opcionalmente mem√≥ria).

Boas pr√°ticas:

minReplicas ‚â• 2 para alta disponibilidade.

maxReplicas compat√≠vel com a capacidade do Node Group (n√£o maior que o que a infra aguenta).

averageUtilization de CPU em 60‚Äì70% (como voc√™ j√° tem).

2.6. ConfigMaps vs Secrets

ConfigMap:

Somente valores n√£o sens√≠veis (URLs, audience, issuer, tempos de expira√ß√£o, nomes de servi√ßo).

Secret:

Tokens, client secrets do Cognito, connection strings completas, senhas de banco, chaves JWT, etc.

Nunca commitar valores reais de secrets.

Usar placeholders (<TO_BE_FILLED_BY_PIPELINE>) ou vari√°veis de ambiente nos pipelines.

Nome dos objetos:

ConfigMap padr√£o: fastfood-config (ou equivalente por servi√ßo).

Secret padr√£o: fastfood-secrets (ou equivalente por servi√ßo).

=====================
3. REGRAS DE AUTENTICA√á√ÉO (Infra + Kubernetes)
=====================

3.1. Autentica√ß√£o na AWS (Terraform / Pipelines)

Pipelines (GitHub Actions) n√£o fazem parte deste rule, mas estes princ√≠pios valem:

N√£o colocar credenciais fixas em .tf.

Qualquer credencial que o Terraform precise deve vir de:

aws-actions/configure-aws-credentials no pipeline, usando a LabRole da Academy.

Se for necess√°rio assumir role:

Usar role-to-assume: var.lab_role ou valores equivalentes configurados no pipeline, n√£o no c√≥digo.

3.2. Acesso ao cluster EKS

Nunca versionar kubeconfig no reposit√≥rio.

Acesso ao cluster deve ser obtido via CLI/pipeline:

```bash
aws eks update-kubeconfig --name <eks_name> --region <aws_region> --role-arn <lab_role>
```

aws_eks_access_entry + aws_eks_access_policy_association s√£o a fonte da verdade de quem pode administrar o cluster.

N√£o adicionar usu√°rios/roles diretamente no aws-auth ConfigMap manualmente; preferir o modelo novo de access entries.

3.3. Tokens de aplica√ß√£o (JWT / Cognito / etc.)

O Terraform n√£o deve gerenciar tokens JWT nem segredos de Cognito diretamente.

Apenas:

Criar/permitir infra necess√°ria (RDS, EKS, Lambdas, etc.).

Permitir que os servi√ßos de aplica√ß√£o usem ConfigMap/Secrets para autentica√ß√£o.

Nos manifests Kubernetes:

Qualquer configura√ß√£o de JWT (issuer, audience, expiration) deve estar em ConfigMap.

Qualquer segredo (chave privada, client secret de IdP, etc.) deve estar em Secret.

=====================
4. DEFINI√á√ÉO DE "FEITO" PARA MUDAN√áAS DE INFRA
=====================

Ao alterar ou adicionar Terraform ou manifests Kubernetes, considere "OK" somente se:

terraform fmt -recursive foi executado e formatou todos os arquivos.

terraform init foi executado (se novos m√≥dulos foram adicionados).

terraform validate foi executado e retornou "Success! The configuration is valid." sem erros.

Todos os erros de valida√ß√£o foram corrigidos antes de commitar.

N√£o h√° TODO pendente em blocos cr√≠ticos.

Os novos recursos:

Est√£o com nomes e tags seguindo o padr√£o.

Respeitam a VPC default.

T√™m seguran√ßa m√≠nima (nada exposto desnecessariamente).

Manifests Kubernetes:

Referenciam o namespace correto.

T√™m Deployment + Service + HPA quando aplic√°vel.

Separaram ConfigMap e Secret corretamente.

Nenhuma credencial foi exposta em .tf ou .yaml.
